---
name: dependency-update
description: 依存関係更新の方針・実施手順・検証/ロールバック方針を提供する。ユーザーが依存更新、ロックファイル更新、互換性/CVE確認を求める場合に使用する。
metadata:
  short-description: 依存更新
---

# Dependency Update

依存関係の更新を安全かつ再現可能に進める。

## 目的

- 更新による影響を最小化し、破壊的変更を見落とさない。
- ロックファイルやバージョンの整合性を保つ。
- 失敗時に戻せる状態を維持する。

## 対象外

- 明示的に更新不要とされている場合。

## 前提確認

- 対象の言語・パッケージ管理ツール（npm/yarn/pnpm、pip/poetry、bundler等）を確認する。
- 更新対象（直接依存・間接依存・全体）と範囲を確認する。
- 既存の規約（README・CONTRIBUTING・CI設定）があれば優先する。
- セキュリティ対応（CVE等）か通常更新かを確認する。
- テストやビルドの実行可否を確認する。
- 不明点は最小限の質問で補う。

## 更新戦略の判断基準

- 直接依存は原則として個別更新し、影響を切り分ける。
- 間接依存のみの更新は、脆弱性対応または互換性問題の解消時に限定する。
- メジャー更新は分離して実施し、移行手順とロールバック手順を先に用意する。
- セキュリティ更新は優先しつつ、緊急時でも最低限の動作確認を省略しない。

## 手順

### 1) 対象と方針の決定

- 目的（脆弱性対応・機能追加・互換性維持）を整理する。
- 重要度に応じて段階的に更新する。
- 可能なら更新を小さく分割する。
- 優先順位の目安は「脆弱性対応」→「互換性維持」→「機能追加」とする。

### 2) 変更内容の把握

- リリースノートと互換性情報を確認する。
- 破壊的変更や移行手順を抽出する。
- 互換性条件（最低バージョン・サポート範囲）を整理する。
- 依存先のサポート期限やEOLがあれば確認する。

### 3) 更新の実行

- 既定の手順で依存を更新する。
- ロックファイルの更新を含める。
- 更新結果を記録する。
- バージョン指定の変更がある場合は理由を記録する。
- lockfile がある環境では、マニフェストと lockfile を常に整合させる。

### 4) 検証

- 既存のテスト・ビルドを実行する。
- 実行できない場合は代替確認を示す。
- 影響が大きい場合はスモークテストを追加する。
- 起動確認や依存ロード確認など、更新対象に近い最小検証を含める。

### 5) 失敗時の対応

- 失敗箇所と再現手順を整理する。
- 可能ならロールバック方針を示す。
- ロールバックが難しい場合は回避策を示す。
- 失敗が環境依存か依存更新由来かを切り分ける。

## ロールバック判断基準

- 既存の重要経路（起動、認証、主要API）が失敗した場合は即時ロールバックを優先する。
- 代替策で本番影響を回避できる場合は、期限付きで回避策を採用して調査を継続する。
- ロールバックしない判断をする場合は、理由と監視項目を明示する。

## 避けるべきこと

- 依存の大量更新を一括で行う。
- リリースノートを確認せずに更新する。
- 失敗時の影響を把握しないまま進める。
- 互換性条件を無視して更新する。
- lockfile だけ、またはマニフェストだけを単独で更新する。

## 出力フォーマット

```markdown
# 依存更新: [対象]

## 方針

- 目的:
- 範囲:

## 更新内容

- 直接依存:
- 間接依存:
- ロックファイル:
- バージョン指定の変更:

## 検証

- 実行したテスト:
- 代替確認:
- スモークテスト:

## 影響

- 互換性:
- 破壊的変更:
- EOL/サポート期限:

## ロールバック

- 方法:
- 条件:
- 回避策:
```

## 返答のガイド

- 変更範囲と理由を先に書く。
- 互換性への影響を短く示す。
- テスト未実行の場合は理由と代替確認を明記する。
- 不明点は短く確認する。
- ロールバックの要否と判断理由を明記する。
