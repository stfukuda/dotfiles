---
name: refactor-safely
description: 既存挙動を維持する段階的リファクタの手順と安全確認事項を提供する。ユーザーがコード整理・設計改善を安全に進めるリファクタ計画を求める場合に使用する。
metadata:
  short-description: 安全なリファクタ
---

# Refactor Safely

既存挙動を維持しつつ、変更を小さく分割して安全にリファクタする。

## 目的

- 既存挙動の維持を最優先にする。
- 変更を小さくし、差分の検証を容易にする。
- 失敗時に戻せる状態を保つ。

## 対象外

- 小さな変更のみで、リファクタ計画が不要な場合。
- 自己完結で検証が不要な軽微変更。

## 適用境界

- 根本原因調査が主目的なら debug-fix を優先する。
- 実装計画全体の整理が主目的なら planner を優先し、挙動維持の実施段階で本スキルを使う。
- 仕様変更を伴う場合は、リファクタ工程と仕様変更工程を分離して扱う。

## レビュー・改善サイクル（必須）

- 生成・修正する内容（計画、手順、文面、設定、変更案など）は、提示または適用前にレビューする。
- レビュー結果を反映して改善し、これを3回繰り返す。
- 3回目の改善結果を最終案として採用する。
- ユーザー指定や既存規約がある場合は、それらを優先して最終案に反映する。

## 前提確認

- 目的と非目的を確認する。
- 影響範囲と依存関係を把握する。
- 既存テストの有無と実行可否を確認する。
- 挙動が変わらないことの確認方法を決める。
- 既存の規約（README/CONTRIBUTING/lint/formatter）があれば優先する。
- 不明点は最小限の質問で補う。

## 安全網の用意

- 既存テストを優先して実行する。
- テストが不足している場合は最小限の追加テストを作る。
- 影響が大きい場合はスモークテスト（簡易動作確認）やスナップショットを用意する。
- 言語や成果物の都合でテストが実行できない場合は、代替確認（手動・スモーク・ログ比較）を用意する。
- 必要なら一時的なログやアサーションで確認する。

## 手順

### 1) ベースラインの確立

- 変更前の挙動を把握する。
- `git status` と `git diff` で作業範囲を確認する。
- ベースライン確認に使うテスト/スモーク手順を明文化する。

### 2) 小さく分割

- 変更を独立した小さな単位に分ける。
- 1ステップごとに意味のある中間状態を保つ。
- 必要に応じて中間コミットを作る。
- 1ステップで変更種類を混在させない（命名変更とロジック変更を分離）。

### 3) メカニカルな変換を優先

- リネーム、抽出、分割、インライン化など機械的に追える手順を選ぶ。
- 変更は1種類ずつ行う。

### 4) 検証を繰り返す

- 各ステップ後にテストや動作確認を行う。
- テストが実行できない場合は理由と代替確認を示す。

### 5) 仕上げ

- 不要な一時コード（ログ・アサーション）を除去する。
- スタイル/フォーマットを揃える。
- 変更理由と影響を短く整理する。
- ロールバック条件（どの失敗で戻すか）を明示する。

## 避けるべきこと

- 大規模な一括置換や一度に大量の変更を混ぜる。
- リファクタと挙動変更を同時に行う。
- 検証なしで複数ステップを進める。

## よく使うパターン

- 関数抽出で責務を分ける。
- 共通処理を関数化して重複を除去する。
- 条件分岐をガード節へ移動してネストを浅くする。
- データ構造の変換を局所化して影響範囲を抑える。

## 出力フォーマット

```markdown
# リファクタ計画: [対象]

## 目的

- [目的1]

## 影響範囲

- [ファイル/モジュール]

## ステップ

1. [小さな変更]
2. [検証]
3. [次の変更]

## 検証

- 実行したテスト:
- 代替確認:
- 未検証項目:

## リスク

- [リスク]
  - 対応: [対策]

## ロールバック条件

- [失敗条件]
- [戻し方]
```

## 返答のガイド

- 変更点・意図・検証・未検証を簡潔に報告する。
- 実施した検証（テスト・手動確認）を明記する。
- テストできない場合は理由と代替検証を示す。
- 追加で安全性を高める提案があれば添える。
