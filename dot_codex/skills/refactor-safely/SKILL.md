---
name: refactor-safely
description: 既存挙動を保ったまま段階的にリファクタする手順・確認事項を提供する。ユーザーがコード整理、設計改善、リファクタ計画の立案を求める場合に使用する。
metadata:
  short-description: 安全なリファクタ
---

# Refactor Safely

既存挙動を維持しつつ、変更を小さく分割して安全にリファクタする。

## 目的

- 既存挙動の維持を最優先にする。
- 変更を小さくし、差分の検証を容易にする。
- 失敗時に戻せる状態を保つ。

## 対象外

- 小さな変更のみで、リファクタ計画が不要な場合。
- 自己完結で検証が不要な軽微変更。

## 前提確認

- 目的と非目的を確認する。
- 影響範囲と依存関係を把握する。
- 既存テストの有無と実行可否を確認する。
- 挙動が変わらないことの確認方法を決める。
- 既存の規約（README/CONTRIBUTING/lint/formatter）があれば優先する。
- 不明点は最小限の質問で補う。

## 安全網の用意

- 既存テストを優先して実行する。
- テストが不足している場合は最小限の追加テストを作る。
- 影響が大きい場合はスモークテスト（簡易動作確認）やスナップショットを用意する。
- 言語や成果物の都合でテストが実行できない場合は、代替確認（手動・スモーク・ログ比較）を用意する。
- 必要なら一時的なログやアサーションで確認する。

## 手順

### 1) ベースラインの確立

- 変更前の挙動を把握する。
- `git status` と `git diff` で作業範囲を確認する。

### 2) 小さく分割

- 変更を独立した小さな単位に分ける。
- 1ステップごとに意味のある中間状態を保つ。
- 必要に応じて中間コミットを作る。

### 3) メカニカルな変換を優先

- リネーム、抽出、分割、インライン化など機械的に追える手順を選ぶ。
- 変更は1種類ずつ行う。

### 4) 検証を繰り返す

- 各ステップ後にテストや動作確認を行う。
- テストが実行できない場合は理由と代替確認を示す。

### 5) 仕上げ

- 不要な一時コード（ログ・アサーション）を除去する。
- スタイル/フォーマットを揃える。
- 変更理由と影響を短く整理する。

## 避けるべきこと

- 大規模な一括置換や一度に大量の変更を混ぜる。
- リファクタと挙動変更を同時に行う。
- 検証なしで複数ステップを進める。

## よく使うパターン

- 関数抽出で責務を分ける。
- 共通処理を関数化して重複を除去する。
- 条件分岐をガード節へ移動してネストを浅くする。
- データ構造の変換を局所化して影響範囲を抑える。

## 出力フォーマット

```markdown
# リファクタ計画: [対象]

## 目的

- [目的1]

## 影響範囲

- [ファイル/モジュール]

## ステップ

1. [小さな変更]
2. [検証]
3. [次の変更]

## 検証

- 実行したテスト:
- 代替確認:

## リスク

- [リスク]
  - 対応: [対策]
```

## 返答のガイド

- 変更点・意図・検証・未検証を簡潔に報告する。
- 実施した検証（テスト・手動確認）を明記する。
- テストできない場合は理由と代替検証を示す。
- 追加で安全性を高める提案があれば添える。
